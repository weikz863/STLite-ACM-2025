# 配对堆 复杂度分析报告

魏可臻

## 配对堆操作简介

我实现的配对堆支持以下操作：新建一个空堆、向堆里插入一个元素、查询堆顶元素、移除堆顶元素、合并两个堆。

一个配对堆是一棵多叉树，满足性质：父亲的权值大于儿子，并且儿子是有顺序的。因此，采用儿子-兄弟表示法存储节点之间的关系。各操作的具体方法如下：

- 新建空堆：初始化数据结构。
- 插入元素：若是空堆，新建一个根节点；否则，先将元素插入一个空堆，再合并两个堆。
- 查询堆顶：直接访问树根。
- 移除堆顶元素：将堆顶节点移除之后，树会分裂成若干个子树，也满足配对堆的性质。按顺序将它们合并。具体来说，先将相邻的子堆从左向右两两配对合并，再将新的若干个堆从右往左依次重组。
- 合并两个堆：若其中一个堆为空，无需改变树的结构；否则，直接比较根节点的权值，较小的成为较大的第一个（最左边一个）儿子。

可以看到，移除堆顶元素最为复杂，它也是配对堆复杂度的核心保障。各操作中，新建空堆、查询堆顶操作显然是 $\Omicron(1)$ 的。对于其余操作，都采用均摊复杂度的分析方法。其中，合并两个堆的复杂度可以视为 $0$ ，因为它出现的次数不超过新建空堆的次数，而实际进行的操作又仅有 $\Omicron(1)$ 。插入元素的均摊复杂度为 $\Omicron(1)$ 。在此基础上，移除堆顶元素的均摊复杂度可以估计为 $\Omicron(\log(n))$ ，其中 $n$ 为当前堆的元素数量。但是，此结论的证明较为复杂，所以这里证明一个较弱的结论：插入元素的均摊复杂度为 $\Omicron(\log(n))$ 。在此基础上，移除堆顶元素的均摊复杂度也可视为 $0$ 。

## 具体分析

为了控制配对堆操作的复杂度，只需控制其历史上曾经存在的边数，因为除了移除堆顶操作之外的所有操作最多新增一条边，而移除堆顶的复杂度等于 $\Omicron(1)$ 乘上切断的边数再加 $\Omicron(1)$ 。

配对堆边数的分析中，对边的来源加以分类：

- 插入和合并新增的边数是 $\Omicron(n)$ 的。
- 移除堆顶过程中，配对和重组的过程会新增边，而重组新增的边数又不超过配对新增的边数，所以只要控制配对中新增的边（简称配对边）的数量即可。

采用势能法进行分析。

首先，对于每个不是根的节点 $x$ ，定义其质量（记为 $x.m$）为：当它成为它父亲 $y$ 的儿子时，$y$ 的子树大小 $y.s$。等价地，也是它和它右边的所有兄弟的子树大小之和，再加来自父亲的 $1$。根节点没有质量。

每个节点会预存一定量的势能。每次新增配对边时，会扣除 $1$ 单位势能作为花费。具体而言，非根节点 $x$ 的势能为 $\log(x.m)/2$ 。

合并（包括插入）操作中，一个根节点成为了另一个根节点的儿子，增加了 $\log(n)/2$ 的势能，这由合并的 $\Omicron(\log(n))$ 均摊复杂度支付。

删除操作开始时，仍令分裂出的子树的根继续保有其质量和势能不变。在配对结束时，每个根的势能为它和它右边的所有根的子树大小之和的对数的一半。为了方便分析势能变化，令最左边的尚未配对的根 $x$ 的势能为 $(3/2)\log(x.m)$。于是，在删除开始时，先支付给最左边的根 $\Omicron(\log(n))$ 额外势能，然后依次配对：设配对的节点为 $x,y$ ，它们右边有一个节点 $z$。（$z$ 也可以不存在，此时令 $z.m = 1$）。则过程中，势能的减少量为：

$$\begin{aligned}
&(3/2)\log(x.m) + \log(y.m)/2 + \log(z.m)/2 - \log(x.s + y.s)/2 - \log(x.s + y.s + z.m - 1)/2 - (3/2)\log(z.m) \\
~=~ &(3/2)\log(x.s + y.s + z.m) + \log(y.s + z.m)/2 - \log(x.s + y.s)/2 - \log(x.s + y.s + z.m - 1)/2 - \log(z.m) \\
~=~ &(\log(x.s + y.s + z.m) - \log(x.s + y.s)/2 - \log(z.m)/2) + (\log(x.s + y.s + z.m) - \log(x.s + y.s + z.m - 1))/2 + (\log(y.s + z.m) - \log(z.m))/2 \\
~\geq~ &1 + 0 + 0 \\
~=~ &1
\end{aligned}$$

其中用到不等式 $\log(u + v) \geq \log(u)/2 + \log(v)/2 + 1$，是均值不等式两边取以 $2$ 为底的对数得到的。于是，我们证明了：每进行一次配对，势能减少量至少为 $1$，足够支付新增配对边的花费。

接下来的重组过程中，令最右边的根的势能归零，其余各根的势能为它和它右边的所有根的子树大小之和的对数的一半，不变。于是，从右向左重组时，无论左边或右边的根成为另一个根的儿子，左边的根原先的势能恰好可以全部交给新的儿子，使得它的势能为它父亲的子树大小的对数的一半。

这样，删除操作的分析结束，所有势能都已摆平，势能减少量足够支付新增配对边的花费，配对边的数量被控制住。于是，所有新增边的数量被控制住，各操作的复杂度得到证明。

## 参考资料

Corwin Sinnamon and Robert Tarjan. A Simpler Proof that Pairing Heaps Take O(1) Amortized Time per Insertion. _arXiv:2208.11791_ [cs.DS], 2022.
